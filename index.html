<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu VR Cardboard : Survie aux Personnages</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/zcanter/aframe-gradient-sky@master/dist/gradientsky.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a1a2e; color: #e0e0e0; }
        a-scene {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Permet aux clics de passer à travers si nécessaire, mais les boutons auront la priorité */
            z-index: 10;
        }
        .message-box {
            display: none; /* Caché par défaut et toujours, car les alertes sont supprimées */
        }
        .button-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px; /* Augmente l'espace entre les boutons */
            pointer-events: auto; /* Réactive les événements de pointeur pour les boutons */
            z-index: 11; /* S'assure que les boutons sont au-dessus des autres éléments d'interface */
        }
        .action-button {
            background: linear-gradient(145deg, #6a0572, #440348);
            color: white;
            padding: 15px 30px; /* Plus grand */
            border: none;
            border-radius: 12px; /* Coins plus arrondis */
            cursor: pointer;
            font-size: 1.2em; /* Texte plus grand */
            font-weight: bold;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.5); /* Ombre plus prononcée */
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1.5px; /* Espacement des lettres */
            position: relative; /* Pour l'effet de bulle */
            overflow: hidden;
        }
        .action-button:hover {
            background: linear-gradient(145deg, #440348, #6a0572);
            transform: translateY(-5px); /* S'élève plus haut au survol */
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.7); /* Ombre plus forte au survol */
        }
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            background: #330236; /* Couleur plus sombre au clic */
        }
        /* Effet de bulle sur les boutons */
        .action-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: block;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: all 0.7s ease-in-out;
            z-index: 0;
        }
        .action-button:active::before {
            width: 0;
            height: 0;
            opacity: 1;
            transition: all 0.0s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button id="messageBoxButton">Fermer</button>
        </div>
    </div>
    <div class="button-container">
        <button id="enterVRButton" class="action-button">Entrer en Mode VR / Démarrer le Jeu</button>
        <button id="exitVRButton" class="action-button" style="display: none;">Quitter le Mode VR</button>
        <button id="restartGameButton" class="action-button" style="display: none;">Rejouer</button>
    </div>

    <a-scene vr-mode-ui="enabled: true">
        <!-- cameraRig est l'entité qui se déplace dans le monde. Elle a maintenant le composant gamepad-movement. -->
        <a-entity id="cameraRig" position="0 0 0" gamepad-movement>
            <!-- La tête (caméra) a les look-controls pour le suivi de la tête et un curseur pour l'interaction par le regard -->
            <!-- IMPORTANT : wasd-controls="enabled: false" pour éviter les conflits avec le mouvement personnalisé -->
            <a-entity id="head" camera look-controls wasd-controls="enabled: false" position="0 1.6 0">
                <!-- Le curseur A-Frame gère le réticule et l'interaction par le regard (fuse) -->
                <a-entity
                    cursor="fuse: true; fuseTimeout: 1500"
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.015; radiusOuter: 0.025"
                    material="color: white; shader: flat"
                ></a-entity>
                <!-- Texte du score, positionné tout en haut à gauche de l'écran du joueur -->
                <a-text value="Score: 0" id="scoreText" position="-0.7 0.45 -1.5" width="2" color="white" align="left"></a-text>
                <!-- Barre de vie et texte de vie tout en haut à droite -->
                <a-plane id="healthBar" position="0.7 0.45 -1.5" width="0.4" height="0.05" color="#FF0000"></a-plane>
                <a-text id="healthText" value="Vie: 50" position="0.7 0.45 -1.5" width="0.8" color="white" align="center"></a-text>
                <!-- Texte de statut du jeu (ex: "Partie terminée!") -->
                <a-text value="" id="gameStatusText" position="0 0.5 -2" width="3" color="#FFFF00" align="center"></a-text>
            </a-entity>
        </a-entity>

        <!-- Assets (Modèles GLTF et textures) -->
        <a-assets>
            <!-- Modèle GLTF pour les personnages (CesiumMan) -->
            <a-asset-item id="character-model" src="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/refs/heads/main/2.0/CesiumMan/glTF/CesiumMan.gltf"></a-asset-item>
            <!-- Texture pour le sol -->
            <img id="ground-texture" src="https://img.freepik.com/photos-gratuite/close-up-melange-poudre-argile_23-2148761860.jpg?semt=ais_items_boosted&w=740" alt="Texture de sol">
        </a-assets>

        <!-- Plan du sol avec la texture standard d'A-Frame -->
        <a-plane position="0 0 0" rotation="-90 0 0" width="200" height="200" src="#ground-texture" repeat="4 4"></a-plane>

        <!-- Ciel panoramique avec le dégradé -->
<a-gradient-sky material="shader: gradient; topColor: 70 130 180; bottomColor: 176 224 230;"></a-gradient-sky>

    </a-scene>

    <script type="module">
        // Variables globales pour la configuration Firebase (fournies par l'environnement Canvas)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // Variables de jeu (globales pour être accessibles par le composant et l'UI)
        let score = 0;
        const totalEnemiesToSpawn = 15; // Nombre total d'ennemis à faire apparaître
        let enemiesSpawned = 0; // Compteur d'ennemis déjà apparus
        let gameRunning = false;
        let enemyEntities = []; // Stocke les références aux entités ennemies dans la scène

        const maxPlayerHealth = 50;
        let playerHealth = maxPlayerHealth;

        // Références aux éléments d'UI HTML et A-Frame
        // Note: messageBox est maintenant utilisé uniquement pour les logs console
        const messageBox = document.getElementById('messageBox'); 
        const messageText = document.getElementById('messageText');
        const messageBoxButton = document.getElementById('messageBoxButton');
        const enterVRButton = document.getElementById('enterVRButton');
        const exitVRButton = document.getElementById('exitVRButton');
        const restartGameButton = document.getElementById('restartGameButton');
        const sceneEl = document.querySelector('a-scene');

        // Références aux éléments de l'interface du jeu en VR
        const scoreText = document.getElementById('scoreText');
        const healthBar = document.getElementById('healthBar');
        const healthText = document.getElementById('healthText');
        const gameStatusText = document.getElementById('gameStatusText');

        // --- Fonctions d'UI ---
        // showMessageBox est une fonction interne de débogage/logging, elle n'affiche plus de boîte visible
        function showMessageBox(message) {
            console.log("Message du jeu:", message);
        }

        function hideMessageBox() {
            // Cette fonction est inutile car la boîte est cachée
        }

        // --- Gestion des événements UI HTML ---
        messageBoxButton.addEventListener('click', hideMessageBox);

        enterVRButton.addEventListener('click', () => {
            if (sceneEl) {
                sceneEl.enterVR(); // Entre en mode VR A-Frame
            }
            enterVRButton.style.display = 'none';
            exitVRButton.style.display = 'inline-block';
            restartGameButton.style.display = 'none'; // Cache le bouton rejouer initialement
            startGame(); // Démarre le jeu
        });

        exitVRButton.addEventListener('click', () => {
            if (sceneEl) {
                sceneEl.exitVR(); // Quitte le mode VR A-Frame
            }
            enterVRButton.style.display = 'inline-block';
            exitVRButton.style.display = 'none';
            restartGameButton.style.display = 'none'; // Cache le bouton rejouer
            endGame("Jeu mis en pause."); // Termine le jeu en mode pause (message simplifié)
        });

        restartGameButton.addEventListener('click', () => {
            restartGameButton.style.display = 'none'; // Cache le bouton rejouer
            startGame(); // Redémarre le jeu
        });

        // --- Gestion des événements A-Frame VR ---
        sceneEl.addEventListener('enter-vr', () => {
            enterVRButton.style.display = 'none';
            exitVRButton.style.display = 'inline-block';
            restartGameButton.style.display = 'none';
            // Demande de permission pour l'orientation de l'appareil lors de l'entrée en VR
            // (particulièrement important pour iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(function (response) {
                        if (response === 'granted') {
                            console.log('Orientation activée pour la VR');
                        } else {
                            console.warn('Permission capteur refusée. Le suivi de la tête pourrait être limité.');
                        }
                    })
                    .catch(console.error);
            } else {
                 console.log("Votre appareil ne supporte pas la demande de permission d'orientation, mais le suivi de la tête peut fonctionner si les permissions sont déjà données.");
            }
        });

        sceneEl.addEventListener('exit-vr', () => {
            enterVRButton.style.display = 'inline-block';
            exitVRButton.style.display = 'none';
            restartGameButton.style.display = 'inline-block'; // Affiche le bouton rejouer après avoir quitté la VR
            endGame("Partie terminée !"); // Termine le jeu
        });

        // --- Logique du Jeu ---

        // Fonction pour démarrer une nouvelle partie
        function startGame() {
            score = 0;
            playerHealth = maxPlayerHealth; // Réinitialise la vie
            enemiesSpawned = 0; // Réinitialise le compteur d'ennemis
            gameRunning = true;
            clearEnemies(); // Supprime tous les ennemis précédents
            spawnEnemies(totalEnemiesToSpawn); // Crée de nouveaux ennemis
            updateGameUI();
            gameStatusText.setAttribute('value', 'Survivez aux personnages !');
            console.log("Jeu démarré !"); // Log de débogage
        }

        // Fonction pour terminer la partie
        function endGame(message = "Partie terminée !") {
            gameRunning = false;
            clearEnemies(); // S'assure que tous les ennemis sont supprimés
            gameStatusText.setAttribute('value', message + " Votre score final : " + score + " !");
            console.log(message + " Votre score final : " + score + " !"); // Log de débogage
            restartGameButton.style.display = 'inline-block'; // Montre le bouton rejouer
        }

        // Fonction pour créer et placer un ennemi (personnage)
        function spawnEnemy() {
            if (!gameRunning) return;

            // Position aléatoire dans une zone jouable, éloignée du joueur
            const x = (Math.random() - 0.5) * 15; // entre -7.5 et 7.5
            const z = (Math.random() > 0.5 ? 1 : -1) * (10 + Math.random() * 10); // entre -20 et -10 OU 10 et 20
            const y = 0.8; // Ajusté pour le modèle CesiumMan et pour être clairement au-dessus du sol

            const enemyEl = document.createElement('a-entity');
            enemyEl.setAttribute('gltf-model', '#character-model'); // Utilise le nouveau modèle GLTF
            enemyEl.setAttribute('position', `${x} ${y} ${z}`);
            // Le modèle CesiumMan peut être grand, ajuster l'échelle si nécessaire.
            // Une échelle de 0.5 est souvent un bon point de départ pour les modèles GLTF par défaut.
            enemyEl.setAttribute('scale', '0.5 0.5 0.5'); 
            enemyEl.setAttribute('enemy', 'speed: 0.05'); // Attache le composant ennemi

            // Animation de rotation pour les ennemis (pour un effet visuel)
            enemyEl.setAttribute('animation__rotate', 'property: rotation; to: 0 360 0; loop: true; dur: 8000; easing: linear;');
            
            sceneEl.appendChild(enemyEl);
            enemyEntities.push(enemyEl);
            enemiesSpawned++;

            // Si tous les ennemis initiaux sont apparus, on peut arrêter le spawn ici ou continuer à en faire apparaître périodiquement
            if (enemiesSpawned < totalEnemiesToSpawn) {
                setTimeout(spawnEnemy, 2000 + Math.random() * 1000); // Fait apparaître le prochain après un délai
            }
        }

        // Fonction pour créer plusieurs ennemis
        function spawnEnemies(count) {
            for (let i = 0; i < count; i++) {
                // Initial spawn can be staggered
                setTimeout(spawnEnemy, i * 500); // Apparition toutes les 0.5 secondes
            }
        }

        // Fonction pour supprimer tous les ennemis de la scène
        function clearEnemies() {
            enemyEntities.forEach(enemy => {
                if (enemy.parentNode) {
                    enemy.parentNode.removeChild(enemy);
                }
            });
            enemyEntities = []; // Réinitialise la liste
        }

        // Met à jour l'affichage du score et de la vie
        function updateGameUI() {
            scoreText.setAttribute('value', `Score: ${score}`);
            healthText.setAttribute('value', `Vie: ${playerHealth}`);

            // Met à jour la largeur de la barre de vie
            const healthPercentage = playerHealth / maxPlayerHealth;
            healthBar.setAttribute('width', 0.4 * healthPercentage);
            // Ajuste la position X de la barre pour qu'elle se réduise vers la gauche
            // L'ancrage de la barre est au centre, donc pour qu'elle se réduise depuis la droite,
            // il faut déplacer son centre vers la gauche.
            healthBar.object3D.position.x = 0.7 - (0.4 * (1 - healthPercentage)) / 2; // Position Y et Z sont fixées
        }

        // --- Composant A-Frame pour le mouvement du joueur et la gestion de la manette ---
        AFRAME.registerComponent('gamepad-movement', {
            init: function() {
                this.moveSpeed = 0.08; // Vitesse de déplacement du joueur ajustée pour le jeu de survie
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.gamepadConnected = false;
                this.gamepadIndex = null;
                this.gamepadButtonAPressed = false; // Pour gérer un seul "tir" par pression

                // Cache les références aux entités pour une meilleure performance
                this.headEl = document.querySelector('#head');
                this.sceneEl = this.el.sceneEl; // Référence à la scène A-Frame

                // Écouteurs d'événements pour la connexion/déconnexion de la manette
                window.addEventListener("gamepadconnected", (e) => {
                    console.log("Manette connectée (composant):", e.gamepad.id);
                    this.gamepadConnected = true;
                    this.gamepadIndex = e.gamepad.index;
                });

                window.addEventListener("gamepaddisconnected", (e) => {
                    console.log("Manette déconnectée (composant):", e.gamepad.id);
                    this.gamepadConnected = false;
                    this.gamepadIndex = null;
                });

                // --- Écouteurs d'événements clavier (déplacés dans le composant) ---
                document.addEventListener('keydown', (event) => {
                    if (!gameRunning) return; // Ne pas traiter les entrées si le jeu n'est pas en cours
                    const key = event.key.toLowerCase();
                    switch (key) {
                        case 'z': case 'w': this.moveForward = true; break;
                        case 's': this.moveBackward = true; break;
                        case 'q': case 'a': this.moveLeft = true; break;
                        case 'd': this.moveRight = true; break;
                        case ' ': // Espace pour "tirer" ou interagir (collecter)
                            const cursorEntity = document.querySelector('[cursor]');
                            if (cursorEntity && cursorEntity.components.cursor) {
                                const intersectedEl = cursorEntity.components.cursor.intersectedEl;
                                // Si on regarde un ennemi et qu'on "tire"
                                if (intersectedEl && intersectedEl.parentNode === this.sceneEl && intersectedEl.components.enemy) {
                                    score += 10; // Gagne des points en éliminant un ennemi
                                    updateGameUI();
                                    intersectedEl.components.enemy.handleCollision(); // Retire l'ennemi
                                }
                            }
                            break;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    if (!gameRunning) return;
                    const key = event.key.toLowerCase();
                    switch (key) {
                        case 'z': case 'w': this.moveForward = false; break;
                        case 's': this.moveBackward = false; break;
                        case 'q': case 'a': this.moveLeft = false; break;
                        case 'd': this.moveRight = false; break;
                    }
                });
            },

            tick: function(time, deltaTime) {
                if (!gameRunning) return; // Le mouvement ne fonctionne que si le jeu est actif

                const currentPosition = this.el.object3D.position; // Position de l'entité cameraRig
                const headRotation = this.headEl.object3D.rotation; // Rotation de la tête (caméra)

                let deltaX = 0; // Déplacement latéral
                let deltaZ = 0; // Déplacement avant/arrière

                // Mouvement clavier
                if (this.moveForward) deltaZ -= this.moveSpeed;
                if (this.moveBackward) deltaZ += this.moveSpeed;
                if (this.moveLeft) deltaX -= this.moveSpeed;
                if (this.moveRight) deltaX += this.moveSpeed;

                // Mouvement manette (Joystick gauche)
                if (this.gamepadConnected && this.gamepadIndex !== null) {
                    // Obtient l'état le plus récent de la manette
                    const gamepads = navigator.getGamepads();
                    const gamepad = gamepads[this.gamepadIndex];

                    if (gamepad) {
                        const lx = gamepad.axes[0]; // Axe X du joystick gauche
                        const ly = gamepad.axes[1]; // Axe Y du joystick gauche

                        const deadzone = 0.1; // Pour ignorer les petites dérives du joystick

                        // Applique le mouvement du joystick gauche :
                        // ly (axe Y) contrôle l'avant/arrière (deltaZ)
                        // lx (axe X) contrôle le mouvement latéral (deltaX)
                        // IMPORTANT : Inversion du signe pour ly afin de corriger la direction avant/arrière
                        if (Math.abs(lx) > deadzone) {
                            deltaX += lx * this.moveSpeed;
                        }
                        if (Math.abs(ly) > deadzone) {
                            deltaZ -= ly * this.moveSpeed; // <-- Inversion corrigée ici !
                        }

                        // Bouton A (index 0 pour la plupart des manettes Xbox) pour "tirer"
                        // Le `!this.gamepadButtonAPressed` s'assure qu'un seul événement est déclenché par pression
                        if (gamepad.buttons[0] && gamepad.buttons[0].pressed && !this.gamepadButtonAPressed) {
                            this.gamepadButtonAPressed = true; // Marque le bouton comme pressé
                            // Simule un "clic" sur l'objet actuellement regardé par le curseur A-Frame
                            const cursorEntity = document.querySelector('[cursor]');
                            if (cursorEntity && cursorEntity.components.cursor) {
                                const intersectedEl = cursorEntity.components.cursor.intersectedEl;
                                // Si on regarde un ennemi et qu'on "tirer"
                                if (intersectedEl && intersectedEl.parentNode === this.sceneEl && intersectedEl.components.enemy) {
                                    score += 10; // Gagne des points en éliminant un ennemi
                                    updateGameUI();
                                    intersectedEl.components.enemy.handleCollision(); // Retire l'ennemi
                                }
                            }
                        } else if (gamepad.buttons[0] && !gamepad.buttons[0].pressed) {
                            this.gamepadButtonAPressed = false; // Réinitialise quand le bouton est relâché
                        }
                    }
                }

                // Applique le mouvement au 'cameraRig' en fonction de l'orientation de la tête.
                const forwardVector = new THREE.Vector3(0, 0, -1); // Vecteur "avant" local
                forwardVector.applyEuler(headRotation); // Oriente le vecteur par la rotation de la tête

                const rightVector = new THREE.Vector3(1, 0, 0); // Vecteur "droite" local
                rightVector.applyEuler(headRotation); // Oriente le vecteur par la rotation de la tête

                // Applique les déplacements calculés à la position du cameraRig
                currentPosition.x += forwardVector.x * deltaZ + rightVector.x * deltaX;
                currentPosition.z += forwardVector.z * deltaZ + rightVector.z * deltaX;
                // La position Y (hauteur) reste fixe (1.6m) car le cameraRig ne gère pas la gravité ni le saut.
            }
        });

        // --- NOUVEAU COMPOSANT A-FRAME POUR LE COMPORTEMENT DES ENNEMIS ---
        AFRAME.registerComponent('enemy', {
            schema: {
                speed: {type: 'number', default: 0.03} // Vitesse à laquelle l'ennemi se déplace vers le joueur
            },
            init: function() {
                this.playerEl = document.querySelector('#cameraRig');
                this.sceneEl = this.el.sceneEl;
                this.alive = true; // Drapeaux pour s'assurer que l'ennemi est traité une seule fois lors de la collision
            },
            tick: function(time, deltaTime) {
                if (!gameRunning || !this.alive) return;

                const enemyPosition = this.el.object3D.position;
                const playerPosition = this.playerEl.object3D.position;

                // Calcule le vecteur de direction de l'ennemi vers le joueur
                const direction = new THREE.Vector3();
                direction.subVectors(playerPosition, enemyPosition).normalize();

                // Déplace l'ennemi vers le joueur
                enemyPosition.add(direction.multiplyScalar(this.data.speed));

                // Vérifie la collision avec le joueur (simple vérification de distance)
                const distance = enemyPosition.distanceTo(playerPosition);
                const collisionThreshold = 0.8; // Seuil de collision (ajustez en fonction de la taille du modèle)

                if (distance < collisionThreshold) {
                    this.handleCollision();
                }
            },
            handleCollision: function() {
                if (!this.alive) return; // Évite les collisions multiples avec le même ennemi
                this.alive = false; // Marque l'ennemi comme "non vivant"

                // Réduit la vie du joueur
                playerHealth -= 10;
                updateGameUI();
                console.log(`Le joueur a été touché ! Vie: ${playerHealth}`);

                // Supprime l'ennemi de la scène
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.el);
                    // Supprime l'ennemi du tableau de suivi
                    enemyEntities = enemyEntities.filter(ent => ent !== this.el); 
                }

                // Vérifie si le jeu est terminé
                if (playerHealth <= 0) {
                    endGame("GAME OVER ! Votre vie est tombée à zéro.");
                } else if (enemyEntities.length === 0 && enemiesSpawned >= totalEnemiesToSpawn) {
                    // Condition de victoire si tous les ennemis sont éliminés
                    endGame("Vous avez survécu à la première vague ! Bravo !");
                }
            }
        });


        // --- Initialisation et Permissions ---

        // Script pour la demande de permission d'orientation des capteurs (iOS/Android)
        window.addEventListener('click', function requestDeviceOrientationOnce() {
            window.removeEventListener('click', requestDeviceOrientationOnce);
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(function (response) {
                        if (response === 'granted') {
                            console.log('Permission d\'orientation des capteurs accordée.');
                        } else {
                            console.warn('Permission d\'orientation des capteurs refusée.');
                        }
                    })
                    .catch(console.error);
            }
        }, { once: true });


        // Message initial au chargement de la page
        window.onload = function() {
            console.log("Bienvenue au jeu de survie VR ! Appuyez sur 'Entrer en Mode VR / Démarrer le Jeu' pour commencer.");
            updateGameUI(); // Initialise l'affichage de l'interface
        };
    </script>
</body>
</html>
