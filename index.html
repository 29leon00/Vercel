<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu VR Cardboard : Collecte de Cubes</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a1a2e; color: #e0e0e0; }
        a-scene {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Permet aux clics de passer à travers si nécessaire, mais les boutons auront la priorité */
            z-index: 10;
        }
        .message-box {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            pointer-events: auto; /* Réactive les événements de pointeur pour la boîte elle-même */
            max-width: 80%;
            margin-bottom: 20px;
            display: none; /* Caché par défaut */
        }
        .message-box button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .message-box button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .button-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto; /* Réactive les événements de pointeur pour les boutons */
            z-index: 11; /* S'assure que les boutons sont au-dessus des autres éléments d'interface */
        }
        .action-button {
            background: linear-gradient(145deg, #6a0572, #440348);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .action-button:hover {
            background: linear-gradient(145deg, #440348, #6a0572);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
        }
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button id="messageBoxButton">Fermer</button>
        </div>
    </div>
    <div class="button-container">
        <button id="enterVRButton" class="action-button">Entrer en Mode VR / Démarrer le Jeu</button>
        <button id="exitVRButton" class="action-button" style="display: none;">Quitter le Mode VR</button>
        <button id="restartGameButton" class="action-button" style="display: none;">Rejouer</button>
    </div>

    <a-scene vr-mode-ui="enabled: true">
        <!-- cameraRig est l'entité qui se déplace dans le monde. La tête (caméra) est son enfant. -->
        <a-entity id="cameraRig" position="0 0 0">
            <!-- La tête (caméra) a les look-controls pour le suivi de la tête et un curseur pour l'interaction par le regard -->
            <!-- IMPORTANT : ajout de wasd-controls="enabled: false" pour éviter les conflits avec le mouvement personnalisé -->
            <a-entity id="head" camera look-controls wasd-controls="enabled: false" position="0 1.6 0">
                <!-- Le curseur A-Frame gère le réticule et l'interaction par le regard (fuse) -->
                <a-entity
                    cursor="fuse: true; fuseTimeout: 1500"
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.015; radiusOuter: 0.025"
                    material="color: white; shader: flat"
                ></a-entity>
                <!-- Texte du score, positionné pour être un HUD VR -->
                <a-text value="Score: 0" id="scoreText" position="-0.5 0.3 -1.5" width="2" color="white"></a-text>
                <!-- Texte des cubes restants, positionné pour être un HUD VR -->
                <a-text value="Cubes restants: 0" id="remainingTargetsText" position="-0.5 0.1 -1.5" width="2" color="white"></a-text>
                <!-- Texte de statut du jeu (ex: "Partie terminée!", "Collectez les cubes!") -->
                <a-text value="" id="gameStatusText" position="0 0.5 -2" width="3" color="#FFFF00" align="center"></a-text>
            </a-entity>
        </a-entity>


        <!-- Plan du sol -->
        <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" color="#808080"></a-plane>

        <!-- Ciel panoramique pour l'arrière-plan -->
        <a-sky src="https://cdn.aframe.io/360-image-gallery-boilerplate/img/sechelt.jpg"></a-sky>
    </a-scene>

    <script type="module">
        // Variables globales pour la configuration Firebase (fournies par l'environnement Canvas)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // Variables de jeu
        let score = 0;
        const totalCubesToCollect = 10; // Nombre total de cubes à collecter pour gagner
        let collectedCubes = 0;
        let gameRunning = false;
        let cubeEntities = []; // Stocke les références aux entités cubes dans la scène

        // Variables de contrôle de mouvement
        const moveSpeed = 0.1; // Vitesse de déplacement
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let gamepadConnected = false;
        let gamepadIndex = null;
        let gamepadButtonAPressed = false; // Pour gérer un seul tir par pression du bouton

        // Références aux éléments d'UI HTML et A-Frame
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxButton = document.getElementById('messageBoxButton');
        const enterVRButton = document.getElementById('enterVRButton');
        const exitVRButton = document.getElementById('exitVRButton');
        const restartGameButton = document.getElementById('restartGameButton');
        const sceneEl = document.querySelector('a-scene');

        const cameraRig = document.getElementById('cameraRig');
        const head = document.getElementById('head');
        const scoreText = document.getElementById('scoreText');
        const remainingTargetsText = document.getElementById('remainingTargetsText');
        const gameStatusText = document.getElementById('gameStatusText');

        // --- Fonctions d'UI ---
        function showMessageBox(message) {
            messageText.innerText = message;
            messageBox.style.display = 'block';
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        // --- Gestion des événements UI HTML ---
        messageBoxButton.addEventListener('click', hideMessageBox);

        enterVRButton.addEventListener('click', () => {
            if (sceneEl) {
                sceneEl.enterVR(); // Entre en mode VR A-Frame
            }
            enterVRButton.style.display = 'none';
            exitVRButton.style.display = 'inline-block';
            restartGameButton.style.display = 'none'; // Cache le bouton rejouer initialement
            startGame(); // Démarre le jeu
        });

        exitVRButton.addEventListener('click', () => {
            if (sceneEl) {
                sceneEl.exitVR(); // Quitte le mode VR A-Frame
            }
            enterVRButton.style.display = 'inline-block';
            exitVRButton.style.display = 'none';
            restartGameButton.style.display = 'none'; // Cache le bouton rejouer
            endGame("Jeu mis en pause. Revenez quand vous voulez !"); // Termine le jeu en mode pause
        });

        restartGameButton.addEventListener('click', () => {
            restartGameButton.style.display = 'none'; // Cache le bouton rejouer
            startGame(); // Redémarre le jeu
        });

        // --- Gestion des événements A-Frame VR ---
        sceneEl.addEventListener('enter-vr', () => {
            enterVRButton.style.display = 'none';
            exitVRButton.style.display = 'inline-block';
            restartGameButton.style.display = 'none';
            // Demande de permission pour l'orientation de l'appareil lors de l'entrée en VR
            // (particulièrement important pour iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(function (response) {
                        if (response === 'granted') {
                            console.log('Orientation activée pour la VR');
                        } else {
                            showMessageBox('Permission capteur refusée. Le suivi de la tête pourrait être limité.');
                        }
                    })
                    .catch(console.error);
            } else {
                 showMessageBox("Votre appareil ne supporte pas la demande de permission d'orientation, mais le suivi de la tête peut fonctionner si les permissions sont déjà données.");
            }
        });

        sceneEl.addEventListener('exit-vr', () => {
            enterVRButton.style.display = 'inline-block';
            exitVRButton.style.display = 'none';
            restartGameButton.style.display = 'inline-block'; // Affiche le bouton rejouer après avoir quitté la VR
            endGame("Partie terminée !"); // Termine le jeu
        });

        // --- Logique du Jeu ---

        // Fonction pour démarrer une nouvelle partie
        function startGame() {
            score = 0;
            collectedCubes = 0;
            gameRunning = true;
            clearCubes(); // Supprime tous les cubes précédents
            spawnCubes(totalCubesToCollect); // Crée de nouveaux cubes
            updateGameUI();
            gameStatusText.setAttribute('value', 'Collectez les cubes !');
            showMessageBox("Jeu démarré ! Collectez les " + totalCubesToCollect + " cubes flottants.");
        }

        // Fonction pour terminer la partie
        function endGame(message = "Partie terminée !") {
            gameRunning = false;
            clearCubes(); // S'assure que tous les cubes sont supprimés
            gameStatusText.setAttribute('value', message + " Votre score final : " + score + " !");
            showMessageBox(message + " Votre score final : " + score + " !");
            restartGameButton.style.display = 'inline-block'; // Montre le bouton rejouer
        }

        // Fonction pour créer et placer un cube
        function spawnCube() {
            // Position aléatoire dans une zone jouable
            const x = (Math.random() - 0.5) * 10; // entre -5 et 5
            const y = 0.5 + Math.random() * 3;   // entre 0.5 et 3.5
            const z = -5 - Math.random() * 10;  // entre -5 et -15 (plus loin que la caméra)

            const cube = document.createElement('a-box');
            cube.setAttribute('position', `${x} ${y} ${z}`);
            const randomColor = getRandomColor();
            cube.setAttribute('color', randomColor);
            cube.setAttribute('scale', '0.5 0.5 0.5'); // Taille du cube
            cube.setAttribute('animation__rotate', 'property: rotation; to: 0 360 0; loop: true; dur: 8000; easing: linear;'); // Animation de rotation
            
            // Interaction par le regard (gaze-based interaction)
            cube.setAttribute('event-set__enter', 'material.color: #ffff00'); // Surligne en jaune au survol
            cube.setAttribute('event-set__leave', `material.color: ${randomColor}`); // Revient à la couleur d'origine
            // Note: l'événement 'click' sur le cube est déclenché par le curseur A-Frame (gaze fuse)
            cube.setAttribute('event-set__click', 'scale: 0.2 0.2 0.2; material.color: #007bff;'); // Effet de rétrécissement au clic
            cube.setAttribute('animation__collect', 'property: scale; to: 0 0 0; dur: 100; easing: easeOutQuad; startEvents: animationcomplete__click');

            // Événement de clic pour collecter le cube (déclenché par le gaze ou par les contrôles manuels)
            cube.addEventListener('click', function() {
                if (gameRunning) {
                    collectCube(this);
                }
            });

            sceneEl.appendChild(cube);
            cubeEntities.push(cube);
        }

        // Fonction de collecte de cube
        function collectCube(cubeElement) {
            collectedCubes++;
            score += 10; // Chaque cube rapporte 10 points
            updateGameUI();
            cubeElement.parentNode.removeChild(cubeElement); // Supprime le cube de la scène
            cubeEntities = cubeEntities.filter(ent => ent !== cubeElement); // Supprime de la liste
            checkWinCondition();
        }

        // Fonction pour générer une couleur aléatoire
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Fonction pour créer plusieurs cubes
        function spawnCubes(count) {
            for (let i = 0; i < count; i++) {
                spawnCube();
            }
        }

        // Fonction pour supprimer tous les cubes de la scène
        function clearCubes() {
            cubeEntities.forEach(cube => {
                if (cube.parentNode) {
                    cube.parentNode.removeChild(cube);
                }
            });
            cubeEntities = []; // Réinitialise la liste
        }

        // Met à jour l'affichage du score et des cubes restants
        function updateGameUI() {
            scoreText.setAttribute('value', `Score: ${score}`);
            remainingTargetsText.setAttribute('value', `Cubes restants: ${totalCubesToCollect - collectedCubes}`);
        }

        // Vérifie si la condition de victoire est atteinte
        function checkWinCondition() {
            if (collectedCubes >= totalCubesToCollect) {
                endGame("Félicitations, vous avez collecté tous les cubes !");
            }
        }

        // --- Contrôles Clavier (pour PC) ---
        document.addEventListener('keydown', (event) => {
            if (!gameRunning) return;
            const key = event.key.toLowerCase();
            switch (key) {
                case 'z': // ZQSD (clavier français)
                case 'w': // WASD (clavier anglais)
                    moveForward = true;
                    break;
                case 's':
                    moveBackward = true;
                    break;
                case 'q': // ZQSD
                case 'a': // WASD
                    moveLeft = true;
                    break;
                case 'd':
                    moveRight = true;
                    break;
                case ' ': // Espace pour collecter
                    // Simule un clic sur l'objet actuellement regardé par le curseur A-Frame
                    const cursorEntity = document.querySelector('[cursor]');
                    if (cursorEntity && cursorEntity.components.cursor) {
                        const intersectedEl = cursorEntity.components.cursor.intersectedEl;
                        // S'assure que l'objet est un cube et qu'il est toujours dans la scène
                        if (intersectedEl && intersectedEl.parentNode === sceneEl && intersectedEl.tagName.toLowerCase() === 'a-box') {
                            collectCube(intersectedEl); // Collecte le cube
                        }
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (!gameRunning) return;
            const key = event.key.toLowerCase();
            switch (key) {
                case 'z':
                case 'w':
                    moveForward = false;
                    break;
                case 's':
                    moveBackward = false;
                    break;
                case 'q':
                case 'a':
                    moveLeft = false;
                    break;
                case 'd':
                    moveRight = false;
                    break;
            }
        });

        // --- Contrôles Manette (pour Mobile/PC en mode VR) ---
        window.addEventListener("gamepadconnected", (event) => {
            console.log("Manette connectée à l'index %d : %s. %d boutons, %d axes.",
                event.gamepad.index, event.gamepad.id,
                event.gamepad.buttons.length, event.gamepad.axes.length);
            gamepadConnected = true;
            gamepadIndex = event.gamepad.index;
        });

        window.addEventListener("gamepaddisconnected", (event) => {
            console.log("Manette déconnectée de l'index %d : %s",
                event.gamepad.index, event.gamepad.id);
            gamepadConnected = false;
            gamepadIndex = null;
        });

        // La boucle 'tick' d'A-Frame est parfaite pour les mises à jour continues comme le mouvement.
        sceneEl.addEventListener('tick', () => {
            if (!gameRunning) return;

            // Récupère la position actuelle du 'cameraRig' (l'entité parente qui se déplace)
            const currentPosition = cameraRig.object3D.position;
            // Récupère la rotation de la tête (la caméra enfant) pour orienter le mouvement
            const headRotation = head.object3D.rotation;

            let deltaX = 0; // Déplacement latéral
            let deltaZ = 0; // Déplacement avant/arrière

            // Mouvement clavier (si des touches sont pressées)
            if (moveForward) deltaZ -= moveSpeed;
            if (moveBackward) deltaZ += moveSpeed;
            if (moveLeft) deltaX -= moveSpeed;
            if (moveRight) deltaX += moveSpeed;

            // Mouvement manette (Joystick gauche)
            if (gamepadConnected && gamepadIndex !== null) {
                const gamepad = navigator.getGamepads()[gamepadIndex];
                if (gamepad) {
                    const lx = gamepad.axes[0]; // Axe X du joystick gauche (latéral)
                    const ly = gamepad.axes[1]; // Axe Y du joystick gauche (avant/arrière)

                    // *** LOG DE DEBUG POUR LE JOYSTICK GAUCHE ***
                    // Vérifiez ces valeurs dans la console de votre navigateur (F12)
                    // Elles devraient changer quand vous bougez le joystick.
                    // Si elles restent à 0, le problème vient de la détection de la manette par le navigateur.
                    // console.log(`Gamepad Left Stick: X=${lx.toFixed(2)}, Y=${ly.toFixed(2)}`);

                    const deadzone = 0.1; // Zone morte pour éviter la dérive du joystick
                    
                    // Applique le mouvement du joystick gauche :
                    // ly contrôle l'avant/arrière (deltaZ)
                    // lx contrôle le mouvement latéral (deltaX)
                    // Ces déplacements sont ensuite orientés par la tête
                    if (Math.abs(lx) > deadzone) {
                        deltaX += lx * moveSpeed;
                    }
                    if (Math.abs(ly) > deadzone) {
                        deltaZ += ly * moveSpeed;
                    }

                    // Bouton A (index 0 pour la plupart des manettes Xbox) pour collecter
                    // Assure qu'on ne "tire" qu'une seule fois par pression du bouton
                    if (gamepad.buttons[0] && gamepad.buttons[0].pressed && !gamepadButtonAPressed) {
                        gamepadButtonAPressed = true; // Marque le bouton comme pressé
                        // Simule un clic sur l'objet actuellement regardé par le curseur
                        const cursorEntity = document.querySelector('[cursor]');
                        if (cursorEntity && cursorEntity.components.cursor) {
                            const intersectedEl = cursorEntity.components.cursor.intersectedEl;
                            // S'assure que l'objet est un cube et qu'il est toujours dans la scène
                            if (intersectedEl && intersectedEl.parentNode === sceneEl && intersectedEl.tagName.toLowerCase() === 'a-box') {
                                collectCube(intersectedEl); // Collecte le cube
                            }
                        }
                    } else if (gamepad.buttons[0] && !gamepad.buttons[0].pressed) {
                        gamepadButtonAPressed = false; // Réinitialise quand le bouton est relâché
                    }
                }
            }

            // Applique le mouvement au 'cameraRig' en fonction de l'orientation de la tête.
            // Cela permet d'avancer/reculer dans la direction où la tête regarde,
            // et de strafer (déplacement latéral) par rapport à cette direction.
            // On utilise la bibliothèque THREE.js intégrée à A-Frame pour la manipulation des vecteurs.
            const forwardVector = new THREE.Vector3(0, 0, -1); // Vecteur "avant" local
            forwardVector.applyEuler(headRotation); // Oriente le vecteur par la rotation de la tête

            const rightVector = new THREE.Vector3(1, 0, 0); // Vecteur "droite" local
            rightVector.applyEuler(headRotation); // Oriente le vecteur par la rotation de la tête

            // Applique les déplacements calculés au cameraRig
            currentPosition.x += forwardVector.x * deltaZ + rightVector.x * deltaX;
            currentPosition.z += forwardVector.z * deltaZ + rightVector.z * deltaX;
            // La position Y (hauteur) reste fixe à 1.6 par défaut sur la caméra, le cameraRig ne la gère pas
            // pour éviter de tomber ou de voler sauf si on ajoute une logique de gravité ou de saut.
        });

        // --- Initialisation et Permissions ---

        // Script pour la demande de permission d'orientation des capteurs (iOS/Android)
        // Ce script est placé ici pour s'assurer qu'il s'exécute après le chargement du DOM
        // et qu'il est déclenché par une interaction utilisateur (un clic sur la page).
        window.addEventListener('click', function requestDeviceOrientationOnce() {
            window.removeEventListener('click', requestDeviceOrientationOnce); // Supprime l'écouteur après le premier clic
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(function (response) {
                        if (response === 'granted') {
                            console.log('Permission d\'orientation des capteurs accordée.');
                        } else {
                            console.warn('Permission d\'orientation des capteurs refusée.');
                        }
                    })
                    .catch(console.error);
            }
        }, { once: true }); // Permet à l'écouteur de se déclencher une seule fois


        // Message initial au chargement de la page
        window.onload = function() {
            showMessageBox("Bienvenue au jeu de collecte de cubes VR ! Appuyez sur 'Entrer en Mode VR / Démarrer le Jeu' pour commencer.");
            updateGameUI(); // Initialise l'affichage de l'interface
        };
    </script>
</body>
</html>
